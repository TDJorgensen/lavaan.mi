% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lavaan.mi.R
\name{lavaan.mi}
\alias{lavaan.mi}
\alias{cfa.mi}
\alias{sem.mi}
\alias{growth.mi}
\title{Fit a lavaan Model to Multiple Imputed Data Sets}
\usage{
lavaan.mi(model, data, ...)

cfa.mi(model, data, ...)

sem.mi(model, data, ...)

growth.mi(model, data, ...)
}
\arguments{
\item{model}{The analysis model can be specified using lavaan
\code{\link[lavaan]{model.syntax}} or a parameter table (as returned by
\code{\link[lavaan]{parTable}}).}

\item{data}{A a \code{list} of imputed data sets, or an object class from
which imputed data can be extracted. Recognized classes are
\code{lavaan.mi} (stored in the \verb{@DataList} slot),
\code{amelia} (created by the Amelia package), or
\code{mids} (created by the mice package).}

\item{\dots}{additional arguments to pass to \code{\link[lavaan]{lavaan}} or
\code{\link[lavaan]{lavaanList}}. See also \code{\link[lavaan]{lavOptions}}.
Note that \code{lavaanList} provides parallel computing options, as well as
a \verb{FUN=} argument so the user can extract custom output after the model
is fitted to each imputed data set (see \strong{Examples}).  TIP: If a
custom \code{FUN} is used \emph{and} \code{parallel = "snow"} is requested,
the user-supplied function should explicitly call \code{library} or use
\code{\link[base]{::}} for any functions not part of the base distribution.}
}
\value{
A \code{\linkS4class{lavaan.mi}} object
}
\description{
This function fits a lavaan model to a list of imputed data sets.
}
\note{
This functionality was originally provided via \code{runMI()} in the
\code{semTools} package, but there are differences.  See the README file
on the GitHub page for this package (find link in DESCRIPTION).
}
\examples{
 \dontrun{
## impose missing data for example
HSMiss <- HolzingerSwineford1939[ , c(paste("x", 1:9, sep = ""),
                                      "ageyr","agemo","school")]
set.seed(123)
HSMiss$x5 <- ifelse(HSMiss$x5 <= quantile(HSMiss$x5, .3), NA, HSMiss$x5)
age <- HSMiss$ageyr + HSMiss$agemo/12
HSMiss$x9 <- ifelse(age <= quantile(age, .3), NA, HSMiss$x9)

## impute missing data with Amelia
library(Amelia)
set.seed(456)
HS.amelia <- amelia(HSMiss, m = 20, noms = "school", p2s = FALSE)
imps <- HS.amelia$imputations

## specify CFA model from lavaan's ?cfa help page
HS.model <- '
  visual  =~ x1 + x2 + x3
  textual =~ x4 + x5 + x6
  speed   =~ x7 + x8 + x9
'

## fit model to imputed data sets
fit <- cfa.mi(HS.model, data = imps)

summary(fit, fit.measures = TRUE)
summary(fit, ci = FALSE, fmi = TRUE, output = "data.frame")
summary(fit, ci = FALSE, stand = TRUE, rsq = TRUE)

## model fit. D3 includes information criteria
anova(fit)
## equivalently:
lavTestLRT.mi(fit)
## request D2
anova(fit, test = "D2")
## request fit indices
fitMeasures(fit)


## fit multigroup model without invariance constraints
mgfit.config <- cfa.mi(HS.model, data = imps, estimator = "mlm",
                       group = "school")
## add invariance constraints, and use previous fit as "data"
mgfit.metric <- cfa.mi(HS.model, data = mgfit.config, estimator = "mlm",
                       group = "school", group.equal = "loadings")
mgfit.scalar <- cfa.mi(HS.model, data = mgfit.config, estimator = "mlm",
                       group = "school",
                       group.equal = c("loadings","intercepts"))

## compare fit of 2 models to test metric invariance
## (scaled likelihood ratio test)
lavTestLRT.mi(mgfit.config, mgfit.metric, mgfit.scalar, # or use anova()
              method = "satorra.bentler.2010") # pass argument to lavTestLRT()

## correlation residuals to investigate local misfit
resid(mgfit.scalar, type = "cor.bentler")
## modification indices for fixed parameters, to investigate local misfit
modindices.mi(mgfit.scalar)
## or lavTestScore.mi for modification indices about equality constraints
lavTestScore.mi(mgfit.scalar)

## Wald test of whether latent means are == (fix 3 means to zero in group 2)
eq.means <- ' .p70. == 0
              .p71. == 0
              .p72. == 0 '
lavTestWald.mi(mgfit.scalar, constraints = eq.means)



## ordered-categorical data
HSbinary <- as.data.frame( lapply(HSMiss[ , paste0("x", 1:9)],
                                  FUN = cut, breaks = 2, labels = FALSE) )
HSbinary$school <- HSMiss$school

## impute binary missing data using mice package
library(mice)
set.seed(456)
miceImps <- mice(HSbinary)
## save imputations in a list of data.frames
impList <- list()
for (i in 1:miceImps$m) impList[[i]] <- complete(miceImps, action = i)

## fit model
catout <- cfa.mi(HS.model, data = impList, # can also pass data = miceImps
                 # use lavaanList(FUN=) argument to save zero-cell tables
                 # and obsolete "WRMR" fit index per imputation
                 FUN = function(fit) {
                   list(wrmr = lavaan::fitMeasures(fit, "wrmr"),
                        zeroCells = lavaan::lavInspect(fit, "zero.cell.tables"))
                 })
summary(catout)
lavTestLRT.mi(catout, test = "D2", pool.robust = TRUE)
fitMeasures(catout, fit.measures = c("rmsea","srmr","cfi"),
            test = "D2", pool.robust = TRUE)

## extract custom output
sapply(catout@funList, function(x) x$wrmr) # WRMR for each imputation
catout@funList[[1]]$zeroCells # zero-cell tables for first imputation
catout@funList[[2]]$zeroCells # zero-cell tables for second imputation ...

}

}
\references{
Enders, C. K. (2010). \emph{Applied missing data analysis}.
New York, NY: Guilford.

Rubin, D. B. (1987). \emph{Multiple imputation for nonresponse in surveys}.
New York, NY: Wiley.
}
\seealso{
\code{\link{poolSat}} for a more efficient method to obtain SEM results
for multiple imputations
}
\author{
Terrence D. Jorgensen (University of Amsterdam; \email{TJorgensen314@gmail.com})
}
